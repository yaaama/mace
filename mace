#!/usr/bin/env dash

# TODO Check for duplicate processes

# // mace
# // ~~~~
# Copyright (C) 2024 Sau P

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# set -xeu
# set -xeu

# running=0

_help() {
    echo "mace [optional]
-h      Show this help message.
-s      Start emacs daemon
-a      Check for active emacs processes.
-sr     Restart Emacs daemon.
-sk     Kill any Emacs daemon instances.
-g      Open Emacs in GUI mode.
-t      Open Emacs in the current terminal.
-deb    Alias for \`emacs --debug-init\`.
-pk     Alias for \`pkill -USR2 emacs\`.
-c      Open Doom capture mode in new frame.
-ds     \`doom sync\`.
-dsu    \`doom sync -u\` Use this if you change an installed package recipe.
-du     \`doom upgrade\`.
-dd     \`doom doctor\`.
-dc     \`doom gc\`. Has replaced the older \`doom purge\` command since 24/03/2024.
"
}

print_err() {
    printf "[mace] error: %s\n" "$1"
}

command_exists() {
    if command -v "$1" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

emacs_exists() {
    command_exists "emacs"
}

doom_exists() {
    command_exists "doom"
}

check_depends() {
    err=0
    if ! emacs_exists; then
        print_err "Emacs does not exist in your path."
        err=1
    fi

    # If there is no 'doom' in the path.
    if ! doom_exists; then
        print_err "Doom does not exist in your path."
        err=1
    fi

    # Exit if error
    if [ "$err" -eq 1 ]; then
        exit 1
    fi
}

# Check the dependencies
check_depends

args_to_add=" "
arg_term=0
arg_start_daemon=0
cmd=""

# If there is no arguments, launch emacsclient!
if [ "$#" -eq 0 ]; then
    emacsclient -a="" -nw "$@" 2>/dev/null
    exit 0
fi

# Check if emacs is running currently
emacs_running() {
    if ! pidof emacs; then
        return 1
    fi
    return 0
}

# Starts a daemon
start_daemon() {
    if emacs_running; then
        print_err "An emacs client is already running."
        exit 1
    fi
    emacs --daemon
}

start_in_terminal() {
    args_to_add="$args_to_add -t"
}

start_if_no_args_or_display() {
    if [ -n "$1" ]; then
        return 1
    fi
    # If no args or no display variable assume terminal start
    if [ -z "$DISPLAY" ] || [ -n "$TMUX" ]; then
        # If no emacs running, then start daemon up
        if ! emacs_running; then
            echo "Launching Emacs daemon"
            emacsclient -a="" -nw "$@" 2>/dev/null
            exit 0
        fi
        emacsclient -a "" -nc "$@" 2>/dev/null
        exit 0
    fi
}

# Automatically start emacs in terminal if conditions are true
start_if_no_args_or_display "$@"

# Helper functions

# Kills a daemon if it exists
kill_daemon() {
    if emacs_running; then
        # Don't request for confirmation
        emacsclient -e "(setq confirm-kill-emacs nil)" 2>/dev/null
        # Save all buffers and kill
        emacsclient -e "(save-buffers-kill-emacs t nil)" 2>/dev/null
        printf "[mace] Killed emacs daemon.\n"
    else
        printf "[mace] No active daemons to kill.\n"
    fi
}

status_daemon() {
    if emacs_running; then
        printf "[mace] Emacs daemon is ACTIVE.\n"
    else
        printf "[mace] Emacs daemon is not currently running.\n"
    fi
    exit 0
}

# Runs the emacs client
run_eclient() {
    args_to_add="-c -n --alternate-editor= "
    cmd='emacsclient' "$args_to_add"
    $cmd
}

run_gui() {
    cmd='emacsclient -c -n --alternate-editor= '

    if [ -n "$1" ]; then
        $cmd "$@"
    fi
    # current_dir="$(pwd)"
    # $cmd "$current_dir"
    $cmd
}

# Will kill and then restart the emacs daemon.
restart_daemon() {
    kill_daemon &&
        start_daemon
    notify-send -a "mace" "Emacs daemon started!"
}

doom_capture() {
    org-capture || notify-send "Something went wrong..."
    exit 0
}

command=$1

case "$command" in
    # Will print out the available commands
    -h) _help ;;
    # -a Checks for whether server is active
    -a) status_daemon ;;
    -c) doom_capture ;;                   # Opens doom capture window
    -s) start_daemon ;;                   # Starts a server
    -sr) restart_daemon ;;                # Restarts the server daemon
    -sk) kill_daemon ;;                   # Kills the server daemon
    -g) run_gui "$@" ;;                   # Starts Emacs client in GUI mode
    -t) emacsclient -nw "$@" ;;           # This will start the terminal client
    -deb) setsid -f emacs --debug-init ;; # Starts emacs in debug mode
    # Doom Aliases
    -ds) doom sync ;;
    -dsu) doom sync -u ;;
    -du) doom upgrade ;;
    -dc) doom gc ;;
    -dd) doom doctor ;;
    # Will print out help if any other key is typed
    *) _help ;;
esac
